# version 0.0.2
# top nonterminal
program: const_decl* declaration* ENDMARKER

# statement
stmt: (if_stmt | for_stmt | switch_stmt | '{' stmt* '}' | NAME stmt_trailer ';'
     | read_stmt ';' | write_stmt ';' | ';' | return_stmt ';')

stmt_trailer: [subscript] '=' expr | '(' [arglist] ')'

return_stmt: 'return' ['(' expr ')']

if_stmt: 'if' '(' condition ')' stmt ['else' stmt]

condition: expr ('<'|'<='|'>'|'>='|'!='|'==') expr | expr

for_stmt: ('for' '(' NAME '=' expr ';' condition ';'
    NAME '=' NAME ('+'|'-') NUMBER ')' stmt)

switch_stmt: 'switch' '(' expr ')' '{' case_stmt+ default_stmt '}'

case_stmt: 'case' konstant ':' stmt

default_stmt: 'default' ':' stmt

arglist: expr (',' expr)*

read_stmt: 'scanf' '(' NAME (',' NAME)* ')'

write_stmt: 'printf' '(' (expr|STRING [',' expr]) ')'

compound_stmt: const_decl* var_decl* stmt*

# expression
expr: ['+'|'-'] term (('+'|'-') term)*

term: factor (('*'|'/') factor)*

factor: NAME [ factor_trailer ] | NUMBER | CHAR | '(' expr ')'

factor_trailer: subscript | '(' [arglist] ')'

subscript: '[' expr ']'

# declaration
var_decl: type_name var_item (',' var_item)* ';'

var_item: NAME [subscript2]

const_decl: 'const' type_name const_item (',' const_item)* ';'

const_item: NAME '=' konstant

konstant: integer | CHAR

type_name: 'int' | 'char' | 'void'

declaration: type_name NAME decl_trailer

decl_trailer: '(' [paralist] ')' '{' compound_stmt '}' | [subscript2] (',' var_item)* ';'

paralist: type_name NAME (',' type_name NAME)*

subscript2: '[' NUMBER ']'

integer: ['+'|'-'] NUMBER
