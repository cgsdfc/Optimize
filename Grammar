# version 0.0.0
# top nonterminal
program: const_decl* declaration*

# statement
stmt: (if_stmt | for_stmt | switch_stmt | '{' stmt* '}' | NAME stmt_trailer ';'
     | read_stmt ';' | write_stmt ';' | ';' | switch_stmt
     | return_stmt ';' | assign_stmt ';')

stmt_trailer: [subscript] '=' expr | '(' [arglist] ')'

if_stmt: 'if' '(' condition ')' stmt ['else' stmt]

condition: expr relation_op expr | expr

relation_op: '<'|'<='|'>'|'>='|'!='|'=='

for_stmt: ('for' '(' NAME '=' expr ';' condition ';'
    NAME '=' NAME ('+'|'-') NUMBER ')' stmt)

switch_stmt: 'switch' '(' expr ')' '{' case+ default '}'

case: 'case' constant ':' stmt

default: 'default' ':' stmt

arglist: expr (',' expr)*

read_stmt: 'scanf' '(' NAME (',' NAME)* ')'

write_stmt: 'printf' '(' (expr|STRING [',' expr]) ')'

read_stmt: 'return' ['(' expr ')']

compound_stmt: const_decl* var_decl* stmt*

# expression
expr: ['+'|'-'] term (('+'|'-') term)*

term: factor (('*'|'/') factor)*

factor: NAME [ trailer ] | NUMBER | CHARACTER | '(' expr ')'

trailer: subscript | '(' [paralist] ')'

subscript: '[' expr ']'

paralist: type NAME (',' type NAME)*

# declaration
var_decl: type var_item (',' var_item)* ';'

var_item: NAME [subscript2]

const_decl: 'const' type const_item (',' const_item)* ';'

const_item: NAME '=' constant

constant: integer | CHARACTER

type: 'int' | 'char' | 'void'

declaration: type NAME decl_trailer

decl_trailer: '(' [paralist] ')' '{' compound_stmt '}' | [subscript2] (',' var_item)* ';'

subscript2: '[' NUMBER ']'

integer: ['+'|'-'] NUMBER
